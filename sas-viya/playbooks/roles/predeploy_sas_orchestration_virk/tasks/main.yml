---
# tasks file for getLocalVIRK

- name: set facts if possible
  set_fact:
    ORCHESTRATION_URL: "{{ SAS[SAS_LICENSE.viya_version].ORCHESTRATION_URL }}"
    VIRK_COMMIT: "{{ SAS[SAS_LICENSE.viya_version].VIRK_COMMIT }}"
    MIRROR_MANAGER_URL: "{{ SAS[SAS_LICENSE.viya_version].MIRROR_MANAGER_URL }}"
    ORCHESTRATION_MIRROR_MANAGER: "{{ SAS[SAS_LICENSE.viya_version].ORCHESTRATION_MIRROR_MANAGER }}"
    USE_MIRROR: "{{ SAS[SAS_LICENSE.viya_version].USE_MIRROR }}"


  
- name: Ensuring that Git is installed
  yum: name={{ item }} state=latest  
  with_items: 
  - git
  - java-1.8.0-openjdk
  delegate_to: localhost
  run_once: true


    
- name: create local orchestration directory
  file:
    path: "{{ ORCHESTRATION_DIRECTORY }}"
    state: directory
  become: no
  delegate_to: localhost
  run_once: true

- name: Preexisting mirror
  block:
  - name: set mirror usage to true
    set_fact:
      USE_MIRROR: "True"

  - name: "Download and unpack the mirror files from compressed archive at: {{ MIRROR_HTTP }}"
    unarchive:
      remote_src: yes
      src: "{{ MIRROR_HTTP }}"
      dest: "{{ REMOTE_DIRECTORY_MIRROR }}"
    become: no
    delegate_to: controller
    run_once: true
    when: "MIRROR_HTTP.split('?')[0].endswith('.zip') or MIRROR_HTTP.split('?')[0].endswith('.tgz') or MIRROR_HTTP.split('?')[0].endswith('.tar.gz') or MIRROR_HTTP.split('?')[0].endswith('.tar.bz2') or MIRROR_HTTP.split('?')[0].endswith('.tbz') or MIRROR_HTTP.split('?')[0].endswith('.tar.xz') or MIRROR_HTTP.split('?')[0].endswith('.txz')"

  - fail:
      msg: "Supplied Mirror must be an archive file type zip, .tar.gz, .tar.bz2, or .tar.xz"
    when: "not (MIRROR_HTTP.split('?')[0].endswith('.zip') or MIRROR_HTTP.split('?')[0].endswith('.tgz') or MIRROR_HTTP.split('?')[0].endswith('.tar.gz') or MIRROR_HTTP.split('?')[0].endswith('.tar.bz2') or MIRROR_HTTP.split('?')[0].endswith('.tbz') or MIRROR_HTTP.split('?')[0].endswith('.tar.xz') or MIRROR_HTTP.split('?')[0].endswith('.txz'))"
  when: "MIRROR_HTTP != ''"

- name: Mirror needing downloading from sas (only works 3.4 and above, otherwise will be done as part of install).
  block:
  - name: "Download and unpack the mirror manager files for sas from: {{ MIRROR_MANAGER_URL }}"
    unarchive:
      remote_src: yes
      src: "{{ MIRROR_MANAGER_URL }}"
      dest: "{{ ORCHESTRATION_DIRECTORY }}"
      creates: "{{ ORCHESTRATION_MIRROR_MANAGER }}"
    become: no
    delegate_to: localhost
    run_once: true

  - name: "Use mirror manager to download a copy of the mirror from sas"
    shell: >-
      time "{{ ORCHESTRATION_MIRROR_MANAGER }}" mirror --deployment-data "{{ LICENSE_FILE }}" --latest --platform x64-redhat-linux-6 --workers 4 -p "{{ LOCAL_DIRECTORY_MIRROR }}" -d
    retries: 5
    delay: 10
    register: result
    until: result.rc == 0
    delegate_to: localhost
    run_once: true


  when: "USE_MIRROR and MIRROR_HTTP == ''"
    
- name: "Download and unpack the orchestration files for sas from: {{ ORCHESTRATION_URL }}"
  unarchive:
    remote_src: yes
    src: "{{ ORCHESTRATION_URL }}"
    dest: "{{ ORCHESTRATION_DIRECTORY }}"
    creates: "{{ ORCHESTRATION_DIRECTORY }}/sas-orchestration"
  become: no
  delegate_to: localhost
  run_once: true
    
- name: Build Orchestration block for sas
  shell: >-
    {{ ORCHESTRATION_DIRECTORY }}/sas-orchestration --verbose build --input {{ LICENSE_FILE }} --output "{{ ORCHESTRATION_DIRECTORY }}/SAS_Viya_playbook.tgz" {% if USE_MIRROR %} --repository-warehouse "file://{{ REMOTE_DIRECTORY_MIRROR }}" {% endif %}
  args:
    chdir: "{{ ORCHESTRATION_DIRECTORY }}"
    creates: "{{ ORCHESTRATION_DIRECTORY }}/SAS_Viya_playbook.tgz"
  become: no
  delegate_to: localhost
  run_once: true
  
- name: Download and unpack the orchestration files for sas
  unarchive:
    remote_src: yes
    src: "{{ ORCHESTRATION_DIRECTORY }}/SAS_Viya_playbook.tgz"
    dest: "{{ ORCHESTRATION_DIRECTORY }}"
    creates: "{{ ORCHESTRATION_DIRECTORY }}/sas_viya_playbook"
  become: no
  delegate_to: localhost
  run_once: true

- name: create local virk directory
  file:
    path: "{{ VIRK_CLONE_DIRECTORY }}"
    state: directory
  become: no
  delegate_to: localhost
  run_once: true

- name: clone the virk directory
  command: >-
    git clone {{ VIRK_ORIGIN_CONNECTOR }} {{ VIRK_CLONE_DIRECTORY }}
  args:
    creates: "{{ VIRK_CLONE_DIRECTORY }}/.git"
  become: no
  delegate_to: localhost
  run_once: true

- name: checkout the proper branch if a VIRK_COMMIT is specified
  command: >-
    git checkout {{ VIRK_COMMIT }} -b workbranch
  args:
    chdir: "{{ VIRK_CLONE_DIRECTORY }}"
  when: "VIRK_COMMIT != ''"
  become: no
  delegate_to: localhost
  run_once: true
  failed_when: false

- name: Create local certificate folder
  file:
    state: directory
    path: "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}"
  delegate_to: localhost

#- name: Create local certificate authority and
#  shell:
#    cmd: |
#      cat > "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/cert_config_file.cfg"<<-EOF
#      dir					= .
#
#      [req]
#      default_bits = 2048
#      prompt = no
#      default_md = sha512
#      req_extensions = req_ext
#      distinguished_name = dn
#
#      [ dn ]
#      C=US
#      O=Self-Signed CA signed Certificate
#      OU=SASViya
#      CN = {{ inventory_hostname }}
#
#      [ req_ext ]
#      subjectAltName = @alt_names
#
#      [ alt_names ]
#      DNS.1 = {{ inventory_hostname }}
#      DNS.2 = {{ ansible_host }}
#      DNS.3 = *.{{ ansible_host }}
#      DNS.4 = *.{{ inventory_hostname }}
#      DNS.5 = localhost
#      IP.1 = 127.0.0.1
#      IP.2 = 0:0:0:0:0:0:0:1
#      EOF
#      cat > "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/mintCert.sh"<<-EOF
#      openssl req -new -newkey rsa:2048 -keyout "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/{{ SSL_CHILD_KEY_FILENAME }}" -out "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/{{ SSL_CHILD_CERT_FILENAME }}.req" -days 3650 -nodes -config "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/cert_config_file.cfg"
#      openssl  x509 -req -sha512 -CA "{{ SSL_WORKING_FOLDER }}/{{SSL_CA_CERT_FILENAME}}" -CAkey "{{ SSL_WORKING_FOLDER }}/{{SSL_CA_KEY_FILENAME}}" -in "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/{{ SSL_CHILD_CERT_FILENAME }}.req" -out "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/{{ SSL_CHILD_CERT_FILENAME }}" -days 3650 -CAcreateserial -extensions req_ext -extfile "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/cert_config_file.cfg"
#      EOF
#      chmod +x "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/mintCert.sh"
#      bash "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/mintCert.sh"
#      # chaining certificates
#      # cat "{{ SSL_WORKING_FOLDER }}/{{SSL_CA_CERT_FILENAME}}" >> "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/{{ SSL_CHILD_CERT_FILENAME }}"
#
#
#  delegate_to: localhost
#
#- name: make sure the security folders exist on the services
#  shell:
#    cmd: |-
#      mkdir -p "{{ SSL_CLIENT_CERT_TARGET_FOLDER }}"
#      mkdir -p "{{ SSL_CLIENT_KEY_TARGET_FOLDER }}"
#- name: copy child cert to all services
#  copy:
#    src: "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/{{ SSL_CHILD_CERT_FILENAME }}"
#    dest: "{{ SSL_CLIENT_CERT_TARGET_FOLDER }}/{{SSL_CHILD_CERT_FILENAME}}"
#    mode: 0644
#
#- name: copy child key to all services
#  copy:
#    src: "{{ SSL_WORKING_FOLDER }}/{{ ansible_host }}/{{ SSL_CHILD_KEY_FILENAME }}"
#    dest: "{{ SSL_CLIENT_KEY_TARGET_FOLDER }}/{{SSL_CHILD_KEY_FILENAME}}"
#    mode: 0600
#
#- name: copy CA cert to all services
#  copy:
#    src: "{{ SSL_WORKING_FOLDER }}/{{SSL_CA_CERT_FILENAME}}"
#    dest: "{{ SSL_CLIENT_CERT_TARGET_FOLDER }}/server-chain.crt"
#    mode: 0644

#- name: set CA as parent in ssl chain
#  lineinfile:
#    path: /etc/httpd/conf.d/ssl.conf
#    regexp: '^SSLCertificateChainFile +.+'
#    line: 'SSLCertificateChainFile {{ SSL_CLIENT_CERT_TARGET_FOLDER }}/server-chain.crt'